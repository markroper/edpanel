buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        // all recent versions of liquibase gradle plugin specify a dependency on liquibase 3.4.2, which contains a
        // mySQL-specific bug that breaks hibernate validation (https://liquibase.jira.com/browse/CORE-2637)
        // To work around this, disable dependency management for selected liquibase dependencies with @jar notation 
        // and manually load in the proper runtime dependency (i.e. swap in liquibase 3.4.0 which works correctly)
        classpath "org.liquibase:liquibase-core:3.4.0"
        classpath "org.liquibase:liquibase-gradle-plugin:1.2.1@jar"
        classpath "org.liquibase:liquibase-groovy-dsl:1.2.1@jar"
        classpath "org.codehaus.groovy:groovy:2.4.1"
        classpath "org.codehaus.groovy:groovy-sql:2.4.1"
        classpath "org.mariadb.jdbc:mariadb-java-client:1.3.4"
    }

}


allprojects {
    apply plugin: 'java'
    apply plugin: 'jacoco'

    apply plugin: 'idea'
    apply plugin: 'eclipse'

    repositories {
        mavenCentral()
    }

    jacoco { 
        toolVersion = "0.7.4.201502262128"
    }

    configurations {
        testArtifacts.extendsFrom testRuntime
    }
    task testJar(type: Jar) {
        classifier "test"
        from sourceSets.test.output
    }
    artifacts {
        testArtifacts testJar
    }

    //Dependencies section:
    ext {
        springVersion = "4.2.3.RELEASE"
        springSecurityVersion = "3.2.5.RELEASE"
        jacksonVersion = "2.6.0"
        apacheHttpVersion = "4.3.3"
        hibernateVersion = "5.0.4.Final"
        hibernateValidator = "5.2.2.Final"
        liquibaseTaskPrefix = 'liquibase'
    }
}

// this plugin must be applied after liquibaseTaskPrefix is defined or the custom prefix will be ignored
apply plugin: 'org.liquibase.gradle'

idea {
    project {
        jdkName = '1.8'
        languageLevel = '1.8'
    }
}

subprojects {
    evaluationDependsOn(':common')

    compileJava {
        options.compilerArgs << "-Werror"
        options.compilerArgs << "-Xlint:unchecked"
    }

    test {
        useTestNG() {
            useDefaultListeners = true
            def suiteFile = "src/test/resources/${project.name}-unit.xml"
            options.suites(suiteFile)
        }

        beforeTest { descriptor ->
            // logger.lifecycle("Running test: " + descriptor)
        }
    }
}

task integrationCodeCoverageReport(type: JacocoReport) {
    group 'Verification'
    description 'runs the integration tests against a local container with code coverage'
    
    // Gather execution data from all subprojects
    // (change this if you e.g. want to calculate unit test/integration test coverage separately)
    executionData fileTree(project.rootDir.absolutePath).include("**/build/jacoco/*.exec")

    // Add all relevant sourcesets from the subprojects
    subprojects.each {
        sourceSets it.sourceSets.main
    }

    reports {
        xml.enabled true
        html.enabled true
        html.destination "${buildDir}/reports/jacoco"
        csv.enabled false
    }
}

def loadProperty(pathRelToProjectDir, property) {
    Properties props = new Properties()
    props.load(new FileInputStream(projectDir.toString() + pathRelToProjectDir))
    return props.get(property).toString()
}

liquibase {
  activities {
    main {
        def dbPropsFilePath = "/warehouse/src/main/resources/database.properties"
        def database_user = project.loadProperty(dbPropsFilePath, "database.user");
        def database_pass = project.loadProperty(dbPropsFilePath, "database.pass");
        def database_host = project.loadProperty(dbPropsFilePath, "database.host");
        def database_port = project.loadProperty(dbPropsFilePath, "database.port");
        def database_name = project.loadProperty(dbPropsFilePath, "database.name");
        def database_ssl  = project.loadProperty(dbPropsFilePath, "database.ssl");
   
        def jdbcUrl = (database_ssl?.equalsIgnoreCase("true")) ?  
                "jdbc:mysql://${database_host}:${database_port}/${database_name}?useSSL=true&requireSSL=true&verifyServerCertificate=false&serverSslCert=${project.rootDir.absolutePath}/warehouse/src/main/resources/db-public-key.ca-bundle" :
                "jdbc:mysql://${database_host}:${database_port}/${database_name}";

      driver 'org.mariadb.jdbc.Driver' 
      changeLogFile 'database/liquibase/db.changelog-master.xml' 
      url jdbcUrl
      username database_user
      password database_pass
    }
  }
}

task populateDatabaseWithDummyData(type: Exec) {
    description 'Clears the database, then fill it with the contents of the dummy database file'
    ext.command = "populate"
}

task refillDatabase(type: Exec) {
    description 'creates everything needed within the database'
    ext.command = "create"
}

def dbConfigure = {
    group 'Database'

    def dbPropsFilePath = "/warehouse/src/main/resources/database.properties"
    def database_user = loadProperty(dbPropsFilePath, "database.user");
    def database_pass = loadProperty(dbPropsFilePath, "database.pass");
    def database_host = loadProperty(dbPropsFilePath, "database.host");
    def database_port = loadProperty(dbPropsFilePath, "database.port");
    def database_name = loadProperty(dbPropsFilePath, "database.name");
    def database_ssl  = loadProperty(dbPropsFilePath, "database.ssl");
    
    def args = [ './database/db.sh', ext.command, database_user, database_pass, database_port, database_host, database_name]

    if (database_ssl?.equalsIgnoreCase("true")) { 
        println 'app configured to use SSL...'
        args.add 'anything-in-7th-variable-enables-ssl'
    }
    commandLine args
}

populateDatabaseWithDummyData dbConfigure
refillDatabase dbConfigure

def getDate()  {
    def date = new Date()
    def formattedDate = date.format("yyyy-MM-dd'T'HH:mm:ss")
    return formattedDate
}

def liquibasePatchingTimeStarted = null

liquibaseUpdate.doFirst { 
    liquibasePatchingTimeStarted = getDate()
}

liquibaseUpdate.finalizedBy 'doLiquibaseRollback'

task doLiquibaseRollback { 
    description 'If a liquibase update task runs AND FAILS, this task will automatically be run to execute a rollback'
    group 'Liquibase'
    onlyIf { 
        project.liquibaseUpdate.state.failure != null
    }
    doLast {
        project.ext.liquibaseCommandValue = liquibasePatchingTimeStarted
        project.liquibaseRollbackToDate.execute()
    }
}

// run the integration tests before generating the report
integrationCodeCoverageReport.dependsOn {
      project(':warehouse').integrationLocalWithContainer
}

